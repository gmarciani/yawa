/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface ActivateUserRequest
 */
export interface ActivateUserRequest {
    /**
     *
     * @type {string}
     * @memberof ActivateUserRequest
     */
    'token': string;
}
/**
 *
 * @export
 * @interface ActivateUserResponse
 */
export interface ActivateUserResponse {
    /**
     *
     * @type {string}
     * @memberof ActivateUserResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password': string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
}
/**
 *
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     *
     * @type {User}
     * @memberof CreateUserResponse
     */
    'user': User;
}
/**
 *
 * @export
 * @interface DeleteUserPictureResponse
 */
export interface DeleteUserPictureResponse {
    /**
     *
     * @type {string}
     * @memberof DeleteUserPictureResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface DeleteUserRequest
 */
export interface DeleteUserRequest {
    /**
     *
     * @type {string}
     * @memberof DeleteUserRequest
     */
    'token': string;
}
/**
 *
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    /**
     *
     * @type {string}
     * @memberof DeleteUserResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface DescribeUserProfileResponse
 */
export interface DescribeUserProfileResponse {
    /**
     *
     * @type {UserProfile}
     * @memberof DescribeUserProfileResponse
     */
    'profile': UserProfile;
}
/**
 *
 * @export
 * @interface DescribeUserSettingsResponse
 */
export interface DescribeUserSettingsResponse {
    /**
     *
     * @type {UserSettings}
     * @memberof DescribeUserSettingsResponse
     */
    'settings': UserSettings;
}
/**
 *
 * @export
 * @interface GetAuthenticatedHelloResponse
 */
export interface GetAuthenticatedHelloResponse {
    /**
     *
     * @type {string}
     * @memberof GetAuthenticatedHelloResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface GetOutcomeRequest
 */
export interface GetOutcomeRequest {
    /**
     *
     * @type {string}
     * @memberof GetOutcomeRequest
     */
    'outcome': GetOutcomeRequestOutcomeEnum;
}

export const GetOutcomeRequestOutcomeEnum = {
    Success: 'SUCCESS',
    NotAuthorized: 'NOT_AUTHORIZED',
    NotFound: 'NOT_FOUND',
    BadRequest: 'BAD_REQUEST',
    InternalError: 'INTERNAL_ERROR',
    Random: 'RANDOM'
} as const;

export type GetOutcomeRequestOutcomeEnum = typeof GetOutcomeRequestOutcomeEnum[keyof typeof GetOutcomeRequestOutcomeEnum];

/**
 *
 * @export
 * @interface GetOutcomeResponse
 */
export interface GetOutcomeResponse {
    /**
     *
     * @type {string}
     * @memberof GetOutcomeResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
    /**
     *
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     *
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
}
/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     *
     * @type {string}
     * @memberof LoginRequest
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
    /**
     *
     * @type {boolean}
     * @memberof LoginRequest
     */
    'neverExpire': boolean;
}
/**
 *
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     *
     * @type {string}
     * @memberof LoginResponse
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof LoginResponse
     */
    'accessToken': string;
    /**
     *
     * @type {string}
     * @memberof LoginResponse
     */
    'accessTokenExpiration': string;
    /**
     *
     * @type {string}
     * @memberof LoginResponse
     */
    'refreshToken': string;
    /**
     *
     * @type {string}
     * @memberof LoginResponse
     */
    'refreshTokenExpiration': string;
}
/**
 *
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
    /**
     *
     * @type {string}
     * @memberof LogoutResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface RefreshAuthenticationRequest
 */
export interface RefreshAuthenticationRequest {
    /**
     *
     * @type {string}
     * @memberof RefreshAuthenticationRequest
     */
    'refreshToken': string;
}
/**
 *
 * @export
 * @interface RefreshAuthenticationResponse
 */
export interface RefreshAuthenticationResponse {
    /**
     *
     * @type {string}
     * @memberof RefreshAuthenticationResponse
     */
    'accessToken': string;
    /**
     *
     * @type {string}
     * @memberof RefreshAuthenticationResponse
     */
    'accessTokenExpiration': string;
    /**
     *
     * @type {string}
     * @memberof RefreshAuthenticationResponse
     */
    'refreshToken': string;
    /**
     *
     * @type {string}
     * @memberof RefreshAuthenticationResponse
     */
    'refreshTokenExpiration': string;
}
/**
 *
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     *
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token': string;
    /**
     *
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'password': string;
}
/**
 *
 * @export
 * @interface ResetPasswordResponse
 */
export interface ResetPasswordResponse {
    /**
     *
     * @type {string}
     * @memberof ResetPasswordResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface SendMailRequest
 */
export interface SendMailRequest {
    /**
     *
     * @type {string}
     * @memberof SendMailRequest
     */
    'mailType': SendMailRequestMailTypeEnum;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof SendMailRequest
     */
    'attributes': { [key: string]: string; };
}

export const SendMailRequestMailTypeEnum = {
    UserCreationPending: 'USER_CREATION_PENDING',
    UserCreationConfirmed: 'USER_CREATION_CONFIRMED',
    UserDeletionPending: 'USER_DELETION_PENDING',
    UserDeletionConfirmed: 'USER_DELETION_CONFIRMED',
    PasswordResetPending: 'PASSWORD_RESET_PENDING',
    PasswordResetConfirmed: 'PASSWORD_RESET_CONFIRMED'
} as const;

export type SendMailRequestMailTypeEnum = typeof SendMailRequestMailTypeEnum[keyof typeof SendMailRequestMailTypeEnum];

/**
 *
 * @export
 * @interface SendMailResponse
 */
export interface SendMailResponse {
    /**
     *
     * @type {string}
     * @memberof SendMailResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface SendPasswordResetTokenResponse
 */
export interface SendPasswordResetTokenResponse {
    /**
     *
     * @type {string}
     * @memberof SendPasswordResetTokenResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface SendUserActivationTokenResponse
 */
export interface SendUserActivationTokenResponse {
    /**
     *
     * @type {string}
     * @memberof SendUserActivationTokenResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface SendUserDeletionTokenResponse
 */
export interface SendUserDeletionTokenResponse {
    /**
     *
     * @type {string}
     * @memberof SendUserDeletionTokenResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface UpdateUserPictureRequest
 */
export interface UpdateUserPictureRequest {
    /**
     *
     * @type {File}
     * @memberof UpdateUserPictureRequest
     */
    'file': File;
}
/**
 *
 * @export
 * @interface UpdateUserPictureResponse
 */
export interface UpdateUserPictureResponse {
    /**
     *
     * @type {string}
     * @memberof UpdateUserPictureResponse
     */
    'message': string;
}
/**
 *
 * @export
 * @interface UpdateUserProfileRequest
 */
export interface UpdateUserProfileRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'firstname'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'lastname'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'gender'?: UpdateUserProfileRequestGenderEnum;
    /**
     *
     * @type {string}
     * @memberof UpdateUserProfileRequest
     */
    'dateOfBirth'?: string;
}

export const UpdateUserProfileRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Unspecified: 'UNSPECIFIED'
} as const;

export type UpdateUserProfileRequestGenderEnum = typeof UpdateUserProfileRequestGenderEnum[keyof typeof UpdateUserProfileRequestGenderEnum];

/**
 *
 * @export
 * @interface UpdateUserProfileResponse
 */
export interface UpdateUserProfileResponse {
    /**
     *
     * @type {UserProfile}
     * @memberof UpdateUserProfileResponse
     */
    'profile': UserProfile;
}
/**
 *
 * @export
 * @interface UpdateUserSettingsRequest
 */
export interface UpdateUserSettingsRequest {
    /**
     *
     * @type {boolean}
     * @memberof UpdateUserSettingsRequest
     */
    'isMfaEnabled'?: boolean;
}
/**
 *
 * @export
 * @interface UpdateUserSettingsResponse
 */
export interface UpdateUserSettingsResponse {
    /**
     *
     * @type {UserSettings}
     * @memberof UpdateUserSettingsResponse
     */
    'settings': UserSettings;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'subscriptionPlan': UserSubscriptionPlanEnum;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'isEnabled': boolean;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'isAccountNonExpired': boolean;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'isAccountNonLocked': boolean;
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'isCredentialsNonExpired': boolean;
    /**
     *
     * @type {UserProfile}
     * @memberof User
     */
    'profile': UserProfile;
    /**
     *
     * @type {UserSettings}
     * @memberof User
     */
    'settings': UserSettings;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'id'?: string;
}

export const UserRoleEnum = {
    Admin: 'ADMIN',
    Prometheus: 'PROMETHEUS',
    Normal: 'NORMAL',
    Anonymous: 'ANONYMOUS'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];
export const UserSubscriptionPlanEnum = {
    Free: 'FREE',
    Basic: 'BASIC',
    Professional: 'PROFESSIONAL',
    System: 'SYSTEM'
} as const;

export type UserSubscriptionPlanEnum = typeof UserSubscriptionPlanEnum[keyof typeof UserSubscriptionPlanEnum];

/**
 *
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    'firstname'?: string;
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    'lastname'?: string;
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    'gender'?: UserProfileGenderEnum;
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    'dateOfBirth'?: string;
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    'picture'?: string;
    /**
     *
     * @type {User}
     * @memberof UserProfile
     */
    'user'?: User;
    /**
     *
     * @type {string}
     * @memberof UserProfile
     */
    'id'?: string;
}

export const UserProfileGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE',
    Unspecified: 'UNSPECIFIED'
} as const;

export type UserProfileGenderEnum = typeof UserProfileGenderEnum[keyof typeof UserProfileGenderEnum];

/**
 *
 * @export
 * @interface UserSettings
 */
export interface UserSettings {
    /**
     *
     * @type {boolean}
     * @memberof UserSettings
     */
    'isMfaEnabled': boolean;
    /**
     *
     * @type {User}
     * @memberof UserSettings
     */
    'user'?: User;
    /**
     *
     * @type {string}
     * @memberof UserSettings
     */
    'id'?: string;
}

/**
 * ActivateUserApi - axios parameter creator
 * @export
 */
export const ActivateUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {ActivateUserRequest} activateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser: async (username: string, activateUserRequest: ActivateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('activateUser', 'username', username)
            // verify required parameter 'activateUserRequest' is not null or undefined
            assertParamExists('activateUser', 'activateUserRequest', activateUserRequest)
            const localVarPath = `/users/{username}/activation`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivateUserApi - functional programming interface
 * @export
 */
export const ActivateUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivateUserApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {ActivateUserRequest} activateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser(username: string, activateUserRequest: ActivateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser(username, activateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivateUserApi - factory interface
 * @export
 */
export const ActivateUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivateUserApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {ActivateUserRequest} activateUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(username: string, activateUserRequest: ActivateUserRequest, options?: any): AxiosPromise<ActivateUserResponse> {
            return localVarFp.activateUser(username, activateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivateUserApi - object-oriented interface
 * @export
 * @class ActivateUserApi
 * @extends {BaseAPI}
 */
export class ActivateUserApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {ActivateUserRequest} activateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivateUserApi
     */
    public activateUser(username: string, activateUserRequest: ActivateUserRequest, options?: AxiosRequestConfig) {
        return ActivateUserApiFp(this.configuration).activateUser(username, activateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActuatorApi - axios parameter creator
 * @export
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Actuator web endpoint \'configprops\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configprops: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/configprops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'configprops-prefix\'
         * @param {string} prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configpropsPrefix: async (prefix: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prefix' is not null or undefined
            assertParamExists('configpropsPrefix', 'prefix', prefix)
            const localVarPath = `/manage/configprops/{prefix}`
                .replace(`{${"prefix"}}`, encodeURIComponent(String(prefix)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'env\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        env: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/env`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'env-toMatch\'
         * @param {string} toMatch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        envToMatch: async (toMatch: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toMatch' is not null or undefined
            assertParamExists('envToMatch', 'toMatch', toMatch)
            const localVarPath = `/manage/env/{toMatch}`
                .replace(`{${"toMatch"}}`, encodeURIComponent(String(toMatch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'health-path\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthPath: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/health/**`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        links: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'mappings\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'metrics\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'metrics-requiredMetricName\'
         * @param {string} requiredMetricName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsRequiredMetricName: async (requiredMetricName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requiredMetricName' is not null or undefined
            assertParamExists('metricsRequiredMetricName', 'requiredMetricName', requiredMetricName)
            const localVarPath = `/manage/metrics/{requiredMetricName}`
                .replace(`{${"requiredMetricName"}}`, encodeURIComponent(String(requiredMetricName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'prometheus\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/prometheus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Actuator web endpoint \'shutdown\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdown: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manage/shutdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActuatorApi - functional programming interface
 * @export
 */
export const ActuatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Actuator web endpoint \'configprops\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configprops(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configprops(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'configprops-prefix\'
         * @param {string} prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configpropsPrefix(prefix: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configpropsPrefix(prefix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'env\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async env(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.env(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'env-toMatch\'
         * @param {string} toMatch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async envToMatch(toMatch: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.envToMatch(toMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'health-path\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthPath(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthPath(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async links(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: Link; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.links(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'mappings\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mappings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mappings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'metrics\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metrics(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metrics(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'metrics-requiredMetricName\'
         * @param {string} requiredMetricName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsRequiredMetricName(requiredMetricName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsRequiredMetricName(requiredMetricName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'prometheus\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prometheus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prometheus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Actuator web endpoint \'shutdown\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shutdown(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shutdown(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActuatorApi - factory interface
 * @export
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActuatorApiFp(configuration)
    return {
        /**
         *
         * @summary Actuator web endpoint \'configprops\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configprops(options?: any): AxiosPromise<object> {
            return localVarFp.configprops(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'configprops-prefix\'
         * @param {string} prefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configpropsPrefix(prefix: string, options?: any): AxiosPromise<object> {
            return localVarFp.configpropsPrefix(prefix, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'env\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        env(options?: any): AxiosPromise<object> {
            return localVarFp.env(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'env-toMatch\'
         * @param {string} toMatch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        envToMatch(toMatch: string, options?: any): AxiosPromise<object> {
            return localVarFp.envToMatch(toMatch, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: any): AxiosPromise<object> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'health-path\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthPath(options?: any): AxiosPromise<object> {
            return localVarFp.healthPath(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(options?: any): AxiosPromise<object> {
            return localVarFp.info(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        links(options?: any): AxiosPromise<{ [key: string]: { [key: string]: Link; }; }> {
            return localVarFp.links(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'mappings\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mappings(options?: any): AxiosPromise<object> {
            return localVarFp.mappings(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'metrics\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metrics(options?: any): AxiosPromise<object> {
            return localVarFp.metrics(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'metrics-requiredMetricName\'
         * @param {string} requiredMetricName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsRequiredMetricName(requiredMetricName: string, options?: any): AxiosPromise<object> {
            return localVarFp.metricsRequiredMetricName(requiredMetricName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'prometheus\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prometheus(options?: any): AxiosPromise<object> {
            return localVarFp.prometheus(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Actuator web endpoint \'shutdown\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdown(options?: any): AxiosPromise<object> {
            return localVarFp.shutdown(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActuatorApi - object-oriented interface
 * @export
 * @class ActuatorApi
 * @extends {BaseAPI}
 */
export class ActuatorApi extends BaseAPI {
    /**
     *
     * @summary Actuator web endpoint \'configprops\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public configprops(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).configprops(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'configprops-prefix\'
     * @param {string} prefix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public configpropsPrefix(prefix: string, options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).configpropsPrefix(prefix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'env\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public env(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).env(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'env-toMatch\'
     * @param {string} toMatch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public envToMatch(toMatch: string, options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).envToMatch(toMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public health(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'health-path\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public healthPath(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).healthPath(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'info\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public info(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).info(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public links(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).links(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'mappings\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public mappings(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).mappings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'metrics\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public metrics(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).metrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'metrics-requiredMetricName\'
     * @param {string} requiredMetricName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public metricsRequiredMetricName(requiredMetricName: string, options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).metricsRequiredMetricName(requiredMetricName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'prometheus\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public prometheus(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).prometheus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Actuator web endpoint \'shutdown\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public shutdown(options?: AxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).shutdown(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateUserApi - axios parameter creator
 * @export
 */
export const CreateUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {CreateUserRequest} createUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateUserApi - functional programming interface
 * @export
 */
export const CreateUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateUserApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {CreateUserRequest} createUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateUserApi - factory interface
 * @export
 */
export const CreateUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateUserApiFp(configuration)
    return {
        /**
         *
         * @param {CreateUserRequest} createUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: any): AxiosPromise<CreateUserResponse> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateUserApi - object-oriented interface
 * @export
 * @class CreateUserApi
 * @extends {BaseAPI}
 */
export class CreateUserApi extends BaseAPI {
    /**
     *
     * @param {CreateUserRequest} createUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateUserApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: AxiosRequestConfig) {
        return CreateUserApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeleteUserApi - axios parameter creator
 * @export
 */
export const DeleteUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {DeleteUserRequest} deleteUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, deleteUserRequest: DeleteUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            // verify required parameter 'deleteUserRequest' is not null or undefined
            assertParamExists('deleteUser', 'deleteUserRequest', deleteUserRequest)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeleteUserApi - functional programming interface
 * @export
 */
export const DeleteUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeleteUserApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {DeleteUserRequest} deleteUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, deleteUserRequest: DeleteUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, deleteUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeleteUserApi - factory interface
 * @export
 */
export const DeleteUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeleteUserApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {DeleteUserRequest} deleteUserRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, deleteUserRequest: DeleteUserRequest, options?: any): AxiosPromise<DeleteUserResponse> {
            return localVarFp.deleteUser(username, deleteUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeleteUserApi - object-oriented interface
 * @export
 * @class DeleteUserApi
 * @extends {BaseAPI}
 */
export class DeleteUserApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {DeleteUserRequest} deleteUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeleteUserApi
     */
    public deleteUser(username: string, deleteUserRequest: DeleteUserRequest, options?: AxiosRequestConfig) {
        return DeleteUserApiFp(this.configuration).deleteUser(username, deleteUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeleteUserPictureApi - axios parameter creator
 * @export
 */
export const DeleteUserPictureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPicture: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUserPicture', 'username', username)
            const localVarPath = `/users/{username}/profile/picture`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeleteUserPictureApi - functional programming interface
 * @export
 */
export const DeleteUserPictureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeleteUserPictureApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserPicture(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserPictureResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserPicture(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeleteUserPictureApi - factory interface
 * @export
 */
export const DeleteUserPictureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeleteUserPictureApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPicture(username: string, options?: any): AxiosPromise<DeleteUserPictureResponse> {
            return localVarFp.deleteUserPicture(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeleteUserPictureApi - object-oriented interface
 * @export
 * @class DeleteUserPictureApi
 * @extends {BaseAPI}
 */
export class DeleteUserPictureApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeleteUserPictureApi
     */
    public deleteUserPicture(username: string, options?: AxiosRequestConfig) {
        return DeleteUserPictureApiFp(this.configuration).deleteUserPicture(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GetGreetingsApi - axios parameter creator
 * @export
 */
export const GetGreetingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGreetings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/simple/greetings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetGreetingsApi - functional programming interface
 * @export
 */
export const GetGreetingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetGreetingsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGreetings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthenticatedHelloResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGreetings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetGreetingsApi - factory interface
 * @export
 */
export const GetGreetingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetGreetingsApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGreetings(options?: any): AxiosPromise<GetAuthenticatedHelloResponse> {
            return localVarFp.getGreetings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetGreetingsApi - object-oriented interface
 * @export
 * @class GetGreetingsApi
 * @extends {BaseAPI}
 */
export class GetGreetingsApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetGreetingsApi
     */
    public getGreetings(options?: AxiosRequestConfig) {
        return GetGreetingsApiFp(this.configuration).getGreetings(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GetOutcomeApi - axios parameter creator
 * @export
 */
export const GetOutcomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {GetOutcomeRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutcome: async (request: GetOutcomeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('getOutcome', 'request', request)
            const localVarPath = `/simple/outcome`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (request !== undefined) {
                localVarQueryParameter['request'] = request;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetOutcomeApi - functional programming interface
 * @export
 */
export const GetOutcomeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetOutcomeApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {GetOutcomeRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOutcome(request: GetOutcomeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOutcomeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOutcome(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetOutcomeApi - factory interface
 * @export
 */
export const GetOutcomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetOutcomeApiFp(configuration)
    return {
        /**
         *
         * @param {GetOutcomeRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOutcome(request: GetOutcomeRequest, options?: any): AxiosPromise<GetOutcomeResponse> {
            return localVarFp.getOutcome(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetOutcomeApi - object-oriented interface
 * @export
 * @class GetOutcomeApi
 * @extends {BaseAPI}
 */
export class GetOutcomeApi extends BaseAPI {
    /**
     *
     * @param {GetOutcomeRequest} request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetOutcomeApi
     */
    public getOutcome(request: GetOutcomeRequest, options?: AxiosRequestConfig) {
        return GetOutcomeApiFp(this.configuration).getOutcome(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GetUserProfileApi - axios parameter creator
 * @export
 */
export const GetUserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserProfile', 'username', username)
            const localVarPath = `/users/{username}/profile`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetUserProfileApi - functional programming interface
 * @export
 */
export const GetUserProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetUserProfileApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserProfile(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DescribeUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetUserProfileApi - factory interface
 * @export
 */
export const GetUserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetUserProfileApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProfile(username: string, options?: any): AxiosPromise<DescribeUserProfileResponse> {
            return localVarFp.getUserProfile(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetUserProfileApi - object-oriented interface
 * @export
 * @class GetUserProfileApi
 * @extends {BaseAPI}
 */
export class GetUserProfileApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetUserProfileApi
     */
    public getUserProfile(username: string, options?: AxiosRequestConfig) {
        return GetUserProfileApiFp(this.configuration).getUserProfile(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GetUserSettingsApi - axios parameter creator
 * @export
 */
export const GetUserSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserSettings', 'username', username)
            const localVarPath = `/users/{username}/settings`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetUserSettingsApi - functional programming interface
 * @export
 */
export const GetUserSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetUserSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DescribeUserSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GetUserSettingsApi - factory interface
 * @export
 */
export const GetUserSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetUserSettingsApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(username: string, options?: any): AxiosPromise<DescribeUserSettingsResponse> {
            return localVarFp.getUserSettings(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetUserSettingsApi - object-oriented interface
 * @export
 * @class GetUserSettingsApi
 * @extends {BaseAPI}
 */
export class GetUserSettingsApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetUserSettingsApi
     */
    public getUserSettings(username: string, options?: AxiosRequestConfig) {
        return GetUserSettingsApiFp(this.configuration).getUserSettings(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {LoginRequest} loginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {LoginRequest} loginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         *
         * @param {LoginRequest} loginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     *
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public login(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LogoutApi - axios parameter creator
 * @export
 */
export const LogoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogoutApi - functional programming interface
 * @export
 */
export const LogoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogoutApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LogoutApi - factory interface
 * @export
 */
export const LogoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogoutApiFp(configuration)
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<LogoutResponse> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogoutApi - object-oriented interface
 * @export
 * @class LogoutApi
 * @extends {BaseAPI}
 */
export class LogoutApi extends BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogoutApi
     */
    public logout(options?: AxiosRequestConfig) {
        return LogoutApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RefreshAuthenticationApi - axios parameter creator
 * @export
 */
export const RefreshAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {RefreshAuthenticationRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAuthentication: async (username: string, request: RefreshAuthenticationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('refreshAuthentication', 'username', username)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('refreshAuthentication', 'request', request)
            const localVarPath = `/auth/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (request !== undefined) {
                localVarQueryParameter['request'] = request;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefreshAuthenticationApi - functional programming interface
 * @export
 */
export const RefreshAuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefreshAuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {RefreshAuthenticationRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAuthentication(username: string, request: RefreshAuthenticationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshAuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAuthentication(username, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefreshAuthenticationApi - factory interface
 * @export
 */
export const RefreshAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefreshAuthenticationApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {RefreshAuthenticationRequest} request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAuthentication(username: string, request: RefreshAuthenticationRequest, options?: any): AxiosPromise<RefreshAuthenticationResponse> {
            return localVarFp.refreshAuthentication(username, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefreshAuthenticationApi - object-oriented interface
 * @export
 * @class RefreshAuthenticationApi
 * @extends {BaseAPI}
 */
export class RefreshAuthenticationApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {RefreshAuthenticationRequest} request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefreshAuthenticationApi
     */
    public refreshAuthentication(username: string, request: RefreshAuthenticationRequest, options?: AxiosRequestConfig) {
        return RefreshAuthenticationApiFp(this.configuration).refreshAuthentication(username, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResetPasswordApi - axios parameter creator
 * @export
 */
export const ResetPasswordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {ResetPasswordRequest} resetPasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (username: string, resetPasswordRequest: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('resetPassword', 'username', username)
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResetPasswordApi - functional programming interface
 * @export
 */
export const ResetPasswordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResetPasswordApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {ResetPasswordRequest} resetPasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(username: string, resetPasswordRequest: ResetPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResetPasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(username, resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResetPasswordApi - factory interface
 * @export
 */
export const ResetPasswordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResetPasswordApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {ResetPasswordRequest} resetPasswordRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(username: string, resetPasswordRequest: ResetPasswordRequest, options?: any): AxiosPromise<ResetPasswordResponse> {
            return localVarFp.resetPassword(username, resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResetPasswordApi - object-oriented interface
 * @export
 * @class ResetPasswordApi
 * @extends {BaseAPI}
 */
export class ResetPasswordApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {ResetPasswordRequest} resetPasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResetPasswordApi
     */
    public resetPassword(username: string, resetPasswordRequest: ResetPasswordRequest, options?: AxiosRequestConfig) {
        return ResetPasswordApiFp(this.configuration).resetPassword(username, resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SendMailApi - axios parameter creator
 * @export
 */
export const SendMailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {SendMailRequest} sendMailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail: async (sendMailRequest: SendMailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMailRequest' is not null or undefined
            assertParamExists('sendMail', 'sendMailRequest', sendMailRequest)
            const localVarPath = `/admin/mail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SendMailApi - functional programming interface
 * @export
 */
export const SendMailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SendMailApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {SendMailRequest} sendMailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMail(sendMailRequest: SendMailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendMailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMail(sendMailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SendMailApi - factory interface
 * @export
 */
export const SendMailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SendMailApiFp(configuration)
    return {
        /**
         *
         * @param {SendMailRequest} sendMailRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMail(sendMailRequest: SendMailRequest, options?: any): AxiosPromise<SendMailResponse> {
            return localVarFp.sendMail(sendMailRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SendMailApi - object-oriented interface
 * @export
 * @class SendMailApi
 * @extends {BaseAPI}
 */
export class SendMailApi extends BaseAPI {
    /**
     *
     * @param {SendMailRequest} sendMailRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendMailApi
     */
    public sendMail(sendMailRequest: SendMailRequest, options?: AxiosRequestConfig) {
        return SendMailApiFp(this.configuration).sendMail(sendMailRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SendPasswordResetTokenApi - axios parameter creator
 * @export
 */
export const SendPasswordResetTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPasswordResetToken: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('sendPasswordResetToken', 'username', username)
            const localVarPath = `/users/{username}/tokens/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SendPasswordResetTokenApi - functional programming interface
 * @export
 */
export const SendPasswordResetTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SendPasswordResetTokenApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPasswordResetToken(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendPasswordResetTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPasswordResetToken(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SendPasswordResetTokenApi - factory interface
 * @export
 */
export const SendPasswordResetTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SendPasswordResetTokenApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPasswordResetToken(username: string, options?: any): AxiosPromise<SendPasswordResetTokenResponse> {
            return localVarFp.sendPasswordResetToken(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SendPasswordResetTokenApi - object-oriented interface
 * @export
 * @class SendPasswordResetTokenApi
 * @extends {BaseAPI}
 */
export class SendPasswordResetTokenApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendPasswordResetTokenApi
     */
    public sendPasswordResetToken(username: string, options?: AxiosRequestConfig) {
        return SendPasswordResetTokenApiFp(this.configuration).sendPasswordResetToken(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SendUserActivationTokenApi - axios parameter creator
 * @export
 */
export const SendUserActivationTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendUserActivationToken: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('sendUserActivationToken', 'username', username)
            const localVarPath = `/users/{username}/tokens/activation`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SendUserActivationTokenApi - functional programming interface
 * @export
 */
export const SendUserActivationTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SendUserActivationTokenApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendUserActivationToken(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendUserActivationTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendUserActivationToken(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SendUserActivationTokenApi - factory interface
 * @export
 */
export const SendUserActivationTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SendUserActivationTokenApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendUserActivationToken(username: string, options?: any): AxiosPromise<SendUserActivationTokenResponse> {
            return localVarFp.sendUserActivationToken(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SendUserActivationTokenApi - object-oriented interface
 * @export
 * @class SendUserActivationTokenApi
 * @extends {BaseAPI}
 */
export class SendUserActivationTokenApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendUserActivationTokenApi
     */
    public sendUserActivationToken(username: string, options?: AxiosRequestConfig) {
        return SendUserActivationTokenApiFp(this.configuration).sendUserActivationToken(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SendUserDeletionTokenApi - axios parameter creator
 * @export
 */
export const SendUserDeletionTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendUserDeletionToken: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('sendUserDeletionToken', 'username', username)
            const localVarPath = `/users/{username}/tokens/deletion`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SendUserDeletionTokenApi - functional programming interface
 * @export
 */
export const SendUserDeletionTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SendUserDeletionTokenApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendUserDeletionToken(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendUserDeletionTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendUserDeletionToken(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SendUserDeletionTokenApi - factory interface
 * @export
 */
export const SendUserDeletionTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SendUserDeletionTokenApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendUserDeletionToken(username: string, options?: any): AxiosPromise<SendUserDeletionTokenResponse> {
            return localVarFp.sendUserDeletionToken(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SendUserDeletionTokenApi - object-oriented interface
 * @export
 * @class SendUserDeletionTokenApi
 * @extends {BaseAPI}
 */
export class SendUserDeletionTokenApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SendUserDeletionTokenApi
     */
    public sendUserDeletionToken(username: string, options?: AxiosRequestConfig) {
        return SendUserDeletionTokenApiFp(this.configuration).sendUserDeletionToken(username, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdateUserPictureApi - axios parameter creator
 * @export
 */
export const UpdateUserPictureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserPictureRequest} [updateUserPictureRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPicture: async (username: string, updateUserPictureRequest?: UpdateUserPictureRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserPicture', 'username', username)
            const localVarPath = `/users/{username}/profile/picture`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPictureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateUserPictureApi - functional programming interface
 * @export
 */
export const UpdateUserPictureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateUserPictureApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserPictureRequest} [updateUserPictureRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPicture(username: string, updateUserPictureRequest?: UpdateUserPictureRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserPictureResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPicture(username, updateUserPictureRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdateUserPictureApi - factory interface
 * @export
 */
export const UpdateUserPictureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateUserPictureApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserPictureRequest} [updateUserPictureRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPicture(username: string, updateUserPictureRequest?: UpdateUserPictureRequest, options?: any): AxiosPromise<UpdateUserPictureResponse> {
            return localVarFp.updateUserPicture(username, updateUserPictureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdateUserPictureApi - object-oriented interface
 * @export
 * @class UpdateUserPictureApi
 * @extends {BaseAPI}
 */
export class UpdateUserPictureApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {UpdateUserPictureRequest} [updateUserPictureRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateUserPictureApi
     */
    public updateUserPicture(username: string, updateUserPictureRequest?: UpdateUserPictureRequest, options?: AxiosRequestConfig) {
        return UpdateUserPictureApiFp(this.configuration).updateUserPicture(username, updateUserPictureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdateUserProfileApi - axios parameter creator
 * @export
 */
export const UpdateUserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserProfileRequest} updateUserProfileRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile: async (username: string, updateUserProfileRequest: UpdateUserProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserProfile', 'username', username)
            // verify required parameter 'updateUserProfileRequest' is not null or undefined
            assertParamExists('updateUserProfile', 'updateUserProfileRequest', updateUserProfileRequest)
            const localVarPath = `/users/{username}/profile`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateUserProfileApi - functional programming interface
 * @export
 */
export const UpdateUserProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateUserProfileApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserProfileRequest} updateUserProfileRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfile(username: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(username, updateUserProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdateUserProfileApi - factory interface
 * @export
 */
export const UpdateUserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateUserProfileApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserProfileRequest} updateUserProfileRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfile(username: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: any): AxiosPromise<UpdateUserProfileResponse> {
            return localVarFp.updateUserProfile(username, updateUserProfileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdateUserProfileApi - object-oriented interface
 * @export
 * @class UpdateUserProfileApi
 * @extends {BaseAPI}
 */
export class UpdateUserProfileApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {UpdateUserProfileRequest} updateUserProfileRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateUserProfileApi
     */
    public updateUserProfile(username: string, updateUserProfileRequest: UpdateUserProfileRequest, options?: AxiosRequestConfig) {
        return UpdateUserProfileApiFp(this.configuration).updateUserProfile(username, updateUserProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdateUserSettingsApi - axios parameter creator
 * @export
 */
export const UpdateUserSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserSettingsRequest} updateUserSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings: async (username: string, updateUserSettingsRequest: UpdateUserSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUserSettings', 'username', username)
            // verify required parameter 'updateUserSettingsRequest' is not null or undefined
            assertParamExists('updateUserSettings', 'updateUserSettingsRequest', updateUserSettingsRequest)
            const localVarPath = `/users/{username}/settings`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateUserSettingsApi - functional programming interface
 * @export
 */
export const UpdateUserSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateUserSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserSettingsRequest} updateUserSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSettings(username: string, updateUserSettingsRequest: UpdateUserSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSettings(username, updateUserSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdateUserSettingsApi - factory interface
 * @export
 */
export const UpdateUserSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateUserSettingsApiFp(configuration)
    return {
        /**
         *
         * @param {string} username
         * @param {UpdateUserSettingsRequest} updateUserSettingsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings(username: string, updateUserSettingsRequest: UpdateUserSettingsRequest, options?: any): AxiosPromise<UpdateUserSettingsResponse> {
            return localVarFp.updateUserSettings(username, updateUserSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdateUserSettingsApi - object-oriented interface
 * @export
 * @class UpdateUserSettingsApi
 * @extends {BaseAPI}
 */
export class UpdateUserSettingsApi extends BaseAPI {
    /**
     *
     * @param {string} username
     * @param {UpdateUserSettingsRequest} updateUserSettingsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateUserSettingsApi
     */
    public updateUserSettings(username: string, updateUserSettingsRequest: UpdateUserSettingsRequest, options?: AxiosRequestConfig) {
        return UpdateUserSettingsApiFp(this.configuration).updateUserSettings(username, updateUserSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
